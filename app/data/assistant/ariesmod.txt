Projet : Aries Mod

Aries Mod est un userscript Tampermonkey pour le jeu Magic Garden qui a réuni plus de 10 000 joueurs, avec un backend dédié et un hub communautaire intégré. C'est un projet personnel de Romann qui a démarré comme une expérience technique et qui s'est transformé en un véritable écosystème communautaire.

À propos de Magic Garden :

Magic Garden est un idle game multijoueur disponible sur Discord et sur magicgarden.gg. Le principe : acheter des graines, faire pousser des plantes, les vendre et devenir riche petit à petit. Des mécaniques comme les animaux de compagnie (qui offrent des bonus), la météo (qui influence les prix) et le multijoueur (jusqu'à 6 joueurs, avec des bonus de vente selon le nombre de joueurs dans le salon) ajoutent de la profondeur à un jeu qui semble enfantin au premier abord.

Origine du projet Aries Mod :

Tout est parti d'une soirée Discord entre amis. En tombant sur ce jeu par hasard, première réaction : "C'est enfantin, le gameplay est vraiment pas terrible". Mais très vite, une idée a traversé l'esprit de Romann.

La découverte : "OK le jeu est nul, mais est-ce que je peux pas essayer de devenir le joueur le plus riche ?" Son instinct de développeur s'est activé instantanément.

Le reverse engineering : Romann a commencé à disséquer le jeu, lire le bundle JavaScript minifié, analyser les requêtes réseau, décortiquer chaque message WebSocket. L'objectif : comprendre chaque mécanisme pour savoir ce qui pouvait être exploité.

Le premier mod : Romann a développé un premier mod axé sur l'automatisation pour accumuler de l'argent rapidement et l'a posté dans le Discord public du jeu. Pas de règles, pas de sécurité, le jeu venait de sortir.

Le contact avec les devs : Un développeur du jeu est venu vers Romann. Bienveillant, il a dit être content que quelqu'un s'intéresse à son jeu si tôt, mais que ce type de mod n'était pas autorisé.

Le vrai départ : Et si, au lieu d'automatiser, Romann créait un mod communautaire dont les joueurs ont réellement besoin ? Un mod qui améliore l'expérience sans casser le jeu. C'est là que le vrai projet a commencé, en demandant systématiquement la validation des devs avant chaque feature.

Cette approche transparente a construit une relation de confiance avec les développeurs qui a permis au projet de grandir pendant des mois.

Module 1 : Client (Userscript)

Objectif : Créer un mod Tampermonkey qui enrichit l'expérience Magic Garden sans casser le jeu, en ajoutant des fonctionnalités communautaires et des améliorations de qualité de vie que les joueurs réclament.

L'histoire du mod :

Le mod a évolué au fil des mois, chaque fonctionnalité étant ajoutée en réponse aux besoins de la communauté et validée par les développeurs du jeu.

Les fondations : Première version officielle avec les fonctionnalités les plus demandées par la communauté. Le mod a tout de suite été adopté par les joueurs.

L'explosion : Le jeu n'avait pas de système de salons publics alors que jouer à plusieurs augmente les prix de vente. Romann a créé un bot Discord couplé à l'API du jeu pour lister les salons directement dans le mod. C'est là que le mod est devenu vraiment populaire.

Le mode éditeur : Une idée qui a surpris tout le monde, développeurs inclus. Un mode purement visuel, mais qui a décuplé l'aspect communautaire du jeu.

La maintenance permanente : Le jeu était mis à jour constamment. Plusieurs mises à jour du mod par semaine, parfois par jour. Les systèmes core ont été refondus plusieurs fois : système de sprites, système de données, compatibilité Discord.

Stack technique du client : TypeScript, JavaScript, esbuild, Tampermonkey, Shadow DOM, CSS, HTML.

Fonctionnalités du client :

Gestionnaire d'animaux : création d'équipes, drag-to-reorder, auto-feed par espèce, logs des capacités.

Notifications : alertes d'items rares en shop, météo, niveaux de nourriture des animaux.

Salons publics : listing de salons alimenté par la communauté avec bonus de vente.

Mode éditeur : mode créatif complet, toutes plantes et décors débloqués dans toutes leurs variations.

Locker : protection des récoltes selon les mutations des plantes (gold, rainbow).

QoL intégrés au jeu : Buy All, Sell All, tri d'inventaire, calculateur de valeur, statistiques.

Menu debug complet : visualisation du store Jotai en temps réel, capture de sprites et sons du jeu, messages WebSocket en direct. Très utile pour les autres modders qui voulaient développer leurs propres mods.

Keybinds personnalisables et compatibilité multi-navigateurs (Chrome, Edge, Firefox, Opera GX, Discord).

Et bien d'autres fonctionnalités développées au fil des mois.

Le mod a été développé quotidiennement pendant des mois, la liste complète des fonctionnalités est disponible sur GitHub : https://github.com/Ariedam64/MG-AriesMod

Limites du client : Très sensible aux mises à jour du jeu (bundle minifié qui change fréquemment), compatibilité Discord Activities complexe à maintenir, maintenance fréquente nécessaire (plusieurs mises à jour par semaine voire par jour), systèmes core refondus plusieurs fois.

Module 2 : Backend (VPS)

Objectif : Fournir une infrastructure légère et économique capable de supporter plus de 10 000 utilisateurs pour alimenter les fonctionnalités communautaires du mod : salons, chat en temps réel, amis, groupes et leaderboard.

L'histoire du backend :

Le backend est né d'une nécessité. Quand l'API des salons publics du jeu a été retirée suite à des abus, Romann a décidé de recréer cette fonctionnalité lui-même. Les joueurs du mod deviendraient eux-mêmes les fournisseurs de données.

Phase Supabase : Romann avait prévu 50 utilisateurs maximum, le quota gratuit de 500K requêtes/mois devait suffire. En 1 heure après le déploiement : déjà 50 utilisateurs. En 24 heures : 400. En moins d'une semaine : le quota était atteint.

Migration VPS : Migration sur un VPS Hetzner en 2 jours à 3,6€/mois. Capacité théorique : 20 millions de requêtes/jour. Une optimisation complètement disproportionnée par rapport à Supabase.

Le Community Hub : Avec plus de 1 000 utilisateurs, Romann a décidé de construire ce qui manquait réellement au jeu : un vrai système communautaire. Chat en temps réel, système d'amis, groupes, leaderboard, profils personnalisables avec 7 contrôles de confidentialité. On pouvait voir le jardin en temps réel de ses amis, leur inventaire et leurs animaux, sans être dans leur salon, grâce aux données stockées par le serveur.

Sécurité et compatibilité : Ajout de Discord OAuth pour sécuriser l'authentification. Les événements SSE ne fonctionnaient pas sur Discord, Romann a mis en place un long polling avec système d'événements. Codé pendant une semaine non-stop pour rendre le tout compatible.

L'optimisation : Avec 10 000 joueurs enregistrés et 500 connectés simultanément, le VPS était à 200% de ses capacités avec 5 millions de requêtes/jour. Refactoring massif : requêtes intelligentes, déduplication, polling optimisé. Résultat : 900K requêtes/jour, VPS stable à 25%. Tout ça sur un serveur à 3,6€/mois.

Ko-fi et les supporters : Romann a ajouté une page Ko-fi sans trop s'attendre à des résultats. En une semaine, il avait récolté suffisamment pour couvrir plus d'un an et demi d'hébergement. Des badges Supporter ont été intégrés dans le Community Hub pour remercier les contributeurs.

Stack technique du backend : Node.js, PostgreSQL, Hetzner VPS, Discord OAuth, Long Polling, REST API, Docker.

Fonctionnalités du backend :

Système de salons publics alimenté directement par les joueurs du mod.

Community Hub complet : chat temps réel, amis, groupes, leaderboard, visualisation en temps réel du jardin, inventaire et animaux de ses amis sans être dans leur salon.

Authentification sécurisée via Discord OAuth.

Long polling avec système d'événements (contournement des restrictions Discord).

Dashboard admin pour superviser le backend en temps réel.

Optimisation massive : de 5M à 900K requêtes/jour, VPS à 25% de capacité.

Stratégies d'optimisation du backend :

Cache mémoire TTL 30s pour les données globales (salons, leaderboard, joueurs en ligne).

Rate limiting en PostgreSQL par IP et par joueur, avec blocklist IP.

Long polling avec système de waiters : le serveur attend un événement ou un timeout avant de répondre.

Fan-out unifié : un seul push alimente SSE et long polling simultanément.

Agrégation parallèle : 11 requêtes en Promise.all pour le chargement initial.

Présence avec sweep lazy : le timer ne tourne que quand des joueurs sont connectés.

Déduplication des destinataires pour les événements de présence (amis + groupes).

Bulk upserts pour les joueurs dans un salon (un seul INSERT au lieu de N).

Index partiels et composites PostgreSQL ciblés sur les requêtes fréquentes.

Nettoyage lazy des salons expirés (cleanup-on-read, pas de cron).

Limites du backend : Architecture polling uniquement (pas de SSE à cause des restrictions Discord), single VPS sans redondance, dépendance à Discord OAuth pour l'authentification.

Module 3 : Gemini (Next-gen)

Objectif : Repartir de zéro en collaboration avec un autre développeur pour créer le mod ultime : future-proof, auto-adaptatif aux mises à jour du jeu, compatible tous navigateurs et mobile, et conçu pour être facilement forkable.

Pourquoi Gemini :

Après des mois de développement sur Aries Mod, les limites de l'architecture originale devenaient évidentes. Romann a décidé avec un autre développeur de tout repartir de zéro.

La collaboration : Un autre développeur utilisait également le jeu et avait son propre mod. Ils ont décidé de fusionner leurs deux projets en un seul, en repartant de zéro avec une architecture pensée pour durer.

L'architecture : Des règles strictes documentées, une architecture modulaire avec des couches claires (atoms, globals, modules, features, UI), et une séparation nette des responsabilités. Plus de hardcode de données du jeu, tout est extrait dynamiquement.

La compatibilité : Compatible tous navigateurs dès le départ, optimisé mobile, et conçu pour que n'importe quel développeur puisse fork et ajouter ses propres sections facilement.

Claude comme copilote : L'architecture du projet Gemini est en grande partie gérée grâce à Claude. Des workflows, rules et skills sont définis dans le dossier .claude du projet, ce qui permet de coder de manière beaucoup plus intelligente et propre. Chaque contribution passe par ces guidelines automatiquement.

Stack technique de Gemini : TypeScript (strict), Vite, Jotai, Pixi.js, Shadow DOM, Vitest, ESLint.

Fonctionnalités de Gemini :

Architecture modulaire avec règles strictes documentées.

Auto-adaptation à la structure du jeu (plus de hardcode de données).

Compatible tous navigateurs + optimisé mobile.

20+ features indépendantes et activables individuellement.

API publique exposée (window.Gemini) pour les scripts tiers.

Système de sprites dynamique via MGSprite et données via MGData.

Limites de Gemini : Toujours en cours de développement, architecture plus complexe (courbe d'apprentissage pour les contributeurs).

Repo Gemini : https://github.com/Ariedam64/Gemini

Impact du projet Aries Mod :

10 000+ joueurs enregistrés sur le mod.

500 joueurs connectés simultanément en moyenne.

2 000 utilisateurs réguliers par jour.

50€ récoltés sur Ko-fi en une semaine, de quoi couvrir 1 an et demi d'hébergement.

Un VPS à 3,6€/mois qui gère tout l'écosystème.

Compatible Chrome, Edge, Firefox, Opera GX et Discord Activities.

Ce que ce projet démontre :

La rétro-ingénierie est un outil puissant quand elle est utilisée de manière constructive et transparente.

Sous-estimer sa base d'utilisateurs est la meilleure erreur possible, ça force à apprendre le scaling en conditions réelles.

Un VPS à 3,6€/mois bien configuré peut surpasser des solutions cloud à 25€/mois.

La confiance de la communauté se construit avec de la transparence et en demandant la permission plutôt que le pardon.

Le feedback des utilisateurs est le meilleur carburant pour un développeur.

La suite :

Ce projet a représenté plusieurs mois de développement intensif, a rassemblé une communauté de plus de 10 000 joueurs et a généré suffisamment de soutien pour couvrir plus d'un an et demi d'hébergement. Il évolue aujourd'hui vers Gemini, un projet collaboratif de réécriture complète. L'objectif : un mod future-proof, auto-adaptatif, compatible tous navigateurs, optimisé mobile, et conçu pour être facilement forkable par d'autres développeurs.
